<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: RÃ©fÃ©rence de la classe Enemy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- GÃ©nÃ©rÃ© par Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="#pri-methods">Fonctions membres privÃ©es</a> &#124;
<a href="#pri-attribs">Attributs privÃ©s</a> &#124;
<a href="class_enemy-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle">
<div class="title">RÃ©fÃ©rence de la classe Enemy</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Graphe d'hÃ©ritage de Enemy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_enemy.png" usemap="#Enemy_map" alt=""/>
  <map id="Enemy_map" name="Enemy_map">
<area href="class_character.html" alt="Character" shape="rect" coords="0,0,69,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:aae1f49e02a35dda5fac45028c3d3ea87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#aae1f49e02a35dda5fac45028c3d3ea87">Enemy</a> (<a class="el" href="class_position.html">Position</a> position, int pv, unsigned <a class="el" href="class_enemy.html#a2c157371e28e73bd6e2efda6ef2a8c28">id</a>, <a class="el" href="class_game.html">Game</a> *gam)</td></tr>
<tr class="memdesc:aae1f49e02a35dda5fac45028c3d3ea87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de la classe <a class="el" href="class_enemy.html">Enemy</a>.  <a href="#aae1f49e02a35dda5fac45028c3d3ea87">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:aae1f49e02a35dda5fac45028c3d3ea87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab66e83364e9672785e6da47b503a76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a7ab66e83364e9672785e6da47b503a76">setPlayerMoving</a> (bool b)</td></tr>
<tr class="memdesc:a7ab66e83364e9672785e6da47b503a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode public consiste à mettre à jour l'attribut qui détermine si un joueur a bouger.  <a href="#a7ab66e83364e9672785e6da47b503a76">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a7ab66e83364e9672785e6da47b503a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6aecc5c213b31376046faf5bb4ee1b"><td class="memItemLeft" align="right" valign="top"><a id="ade6aecc5c213b31376046faf5bb4ee1b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#ade6aecc5c213b31376046faf5bb4ee1b">setHitTextureDepart</a> ()</td></tr>
<tr class="memdesc:ade6aecc5c213b31376046faf5bb4ee1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode public faisant appel à la méthode privé <a class="el" href="class_enemy.html#a0223f2d3a71d8d80f4e6e4d760f056b9" title="Méthode privé consiste à chargé la texture de l&#39;ennemi. ">loadTexture()</a> <br /></td></tr>
<tr class="separator:ade6aecc5c213b31376046faf5bb4ee1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8bf4aa1d75720b8d96145ef04ec016"><td class="memItemLeft" align="right" valign="top"><a id="a3b8bf4aa1d75720b8d96145ef04ec016"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a3b8bf4aa1d75720b8d96145ef04ec016">startMovingEnemies</a> ()</td></tr>
<tr class="memdesc:a3b8bf4aa1d75720b8d96145ef04ec016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode public permettant de lancer le thread. <br /></td></tr>
<tr class="separator:a3b8bf4aa1d75720b8d96145ef04ec016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcf21e8970f4f1c98569426a291d46c"><td class="memItemLeft" align="right" valign="top"><a id="aefcf21e8970f4f1c98569426a291d46c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#aefcf21e8970f4f1c98569426a291d46c">spriteLevel</a> ()</td></tr>
<tr class="memdesc:aefcf21e8970f4f1c98569426a291d46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode public faisant appel à la méthode <a class="el" href="class_enemy.html#a0223f2d3a71d8d80f4e6e4d760f056b9" title="Méthode privé consiste à chargé la texture de l&#39;ennemi. ">loadTexture()</a> <br /></td></tr>
<tr class="separator:aefcf21e8970f4f1c98569426a291d46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953b79d8c957dfff682e4efb104382c9"><td class="memItemLeft" align="right" valign="top"><a id="a953b79d8c957dfff682e4efb104382c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a953b79d8c957dfff682e4efb104382c9">nextLevel</a> ()</td></tr>
<tr class="memdesc:a953b79d8c957dfff682e4efb104382c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode public consiste à passé au niveau suivant. <br /></td></tr>
<tr class="separator:a953b79d8c957dfff682e4efb104382c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1d890d928f17a86c05e74d9ed0a19d"><td class="memItemLeft" align="right" valign="top"><a id="a9a1d890d928f17a86c05e74d9ed0a19d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a9a1d890d928f17a86c05e74d9ed0a19d">reload</a> ()</td></tr>
<tr class="memdesc:a9a1d890d928f17a86c05e74d9ed0a19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode public consiste à rechargé l'état de base de l'ennemi. <br /></td></tr>
<tr class="separator:a9a1d890d928f17a86c05e74d9ed0a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03176597f71929d302c8fb0d414c203b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_position.html">Position</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a03176597f71929d302c8fb0d414c203b">getPositionFirst</a> () const</td></tr>
<tr class="memdesc:a03176597f71929d302c8fb0d414c203b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode public consiste à donné la position de départ de l'ennemi.  <a href="#a03176597f71929d302c8fb0d414c203b">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a03176597f71929d302c8fb0d414c203b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_character"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_character')"><img src="closed.png" alt="-"/>&#160;Fonctions membres publiques hÃ©ritÃ©s de <a class="el" href="class_character.html">Character</a></td></tr>
<tr class="memitem:ab25305b796bce77e0962a095278752b2 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#ab25305b796bce77e0962a095278752b2">removePv</a> (int damage)</td></tr>
<tr class="memdesc:ab25305b796bce77e0962a095278752b2 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode public permettant de retirer de la vie au joueur.  <a href="class_character.html#ab25305b796bce77e0962a095278752b2">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:ab25305b796bce77e0962a095278752b2 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d9b96e3b8ff7e2d0e0ccfab3669592 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top"><a id="a18d9b96e3b8ff7e2d0e0ccfab3669592"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a18d9b96e3b8ff7e2d0e0ccfab3669592">move</a> (float f1, float f2)</td></tr>
<tr class="memdesc:a18d9b96e3b8ff7e2d0e0ccfab3669592 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode public permettant de déplacer le joueur. <br /></td></tr>
<tr class="separator:a18d9b96e3b8ff7e2d0e0ccfab3669592 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afb0eef16674964f88e66df19ea07cb inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top"><a id="a2afb0eef16674964f88e66df19ea07cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a2afb0eef16674964f88e66df19ea07cb">manageSprite</a> (float fpsCount, float fpsSpeed, float switchFps, sf::Clock time)</td></tr>
<tr class="memdesc:a2afb0eef16674964f88e66df19ea07cb inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode public permettant de gèrer l'animation du sprite du joueur. <br /></td></tr>
<tr class="separator:a2afb0eef16674964f88e66df19ea07cb inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc27bdd255876169bad2ed0bae0cffb5 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top"><a id="adc27bdd255876169bad2ed0bae0cffb5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#adc27bdd255876169bad2ed0bae0cffb5">Character</a> ()</td></tr>
<tr class="memdesc:adc27bdd255876169bad2ed0bae0cffb5 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par défaut de la classe <a class="el" href="class_character.html">Character</a>. <br /></td></tr>
<tr class="separator:adc27bdd255876169bad2ed0bae0cffb5 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335eab41150e181f30f12172fbe755cd inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a335eab41150e181f30f12172fbe755cd">Character</a> (<a class="el" href="class_position.html">Position</a> position, int pv)</td></tr>
<tr class="memdesc:a335eab41150e181f30f12172fbe755cd inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de la class <a class="el" href="class_character.html">Character</a>.  <a href="class_character.html#a335eab41150e181f30f12172fbe755cd">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a335eab41150e181f30f12172fbe755cd inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60f7783f20fe6ae494fd88793321f71 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#ae60f7783f20fe6ae494fd88793321f71">getPv</a> () const</td></tr>
<tr class="memdesc:ae60f7783f20fe6ae494fd88793321f71 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de l'attribut privé pv.  <a href="class_character.html#ae60f7783f20fe6ae494fd88793321f71">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:ae60f7783f20fe6ae494fd88793321f71 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fed976b8898b1ecb66ac83a37189ec9 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">const sf::RectangleShape &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a2fed976b8898b1ecb66ac83a37189ec9">getHitbox</a> () const</td></tr>
<tr class="memdesc:a2fed976b8898b1ecb66ac83a37189ec9 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de l'attribut privé hitbox_.  <a href="class_character.html#a2fed976b8898b1ecb66ac83a37189ec9">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a2fed976b8898b1ecb66ac83a37189ec9 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eae17ee51cc959284a9473b33081e3a inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_position.html">Position</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a8eae17ee51cc959284a9473b33081e3a">getPosition</a> () const</td></tr>
<tr class="memdesc:a8eae17ee51cc959284a9473b33081e3a inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de l'attribut privé position_.  <a href="class_character.html#a8eae17ee51cc959284a9473b33081e3a">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a8eae17ee51cc959284a9473b33081e3a inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2566cb9dd0f8f30f02586f42eb993958 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">sf::Sprite *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a2566cb9dd0f8f30f02586f42eb993958">getSprite</a> () const</td></tr>
<tr class="memdesc:a2566cb9dd0f8f30f02586f42eb993958 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de l'attribut privé sprite_.  <a href="class_character.html#a2566cb9dd0f8f30f02586f42eb993958">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a2566cb9dd0f8f30f02586f42eb993958 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043a761cf76bb49fb5b2ef68101a7123 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a043a761cf76bb49fb5b2ef68101a7123">setPositionSprite</a> (sf::Vector2f p)</td></tr>
<tr class="memdesc:a043a761cf76bb49fb5b2ef68101a7123 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setteur de l'attribut privé sprite_.  <a href="class_character.html#a043a761cf76bb49fb5b2ef68101a7123">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a043a761cf76bb49fb5b2ef68101a7123 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55489f01daf99e1c6e310b5c586eb10 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#aa55489f01daf99e1c6e310b5c586eb10">setAnimX</a> (Direction direction)</td></tr>
<tr class="memdesc:aa55489f01daf99e1c6e310b5c586eb10 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter permettant de mettre à jour l'attribut anim_.  <a href="class_character.html#aa55489f01daf99e1c6e310b5c586eb10">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:aa55489f01daf99e1c6e310b5c586eb10 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab9c2ea40afb93b96f60d86b0d7923f inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#abab9c2ea40afb93b96f60d86b0d7923f">setAnimY</a> (Direction direction)</td></tr>
<tr class="memdesc:abab9c2ea40afb93b96f60d86b0d7923f inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter permettant de mettre à jour l'attribut anim_.  <a href="class_character.html#abab9c2ea40afb93b96f60d86b0d7923f">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:abab9c2ea40afb93b96f60d86b0d7923f inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea58cde06f000d6606e290cce02e735 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">const State &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a3ea58cde06f000d6606e290cce02e735">getState</a> () const</td></tr>
<tr class="memdesc:a3ea58cde06f000d6606e290cce02e735 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de l'attribut privé state_.  <a href="class_character.html#a3ea58cde06f000d6606e290cce02e735">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a3ea58cde06f000d6606e290cce02e735 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a18e8f862e8f96a79cc524ccd373f4 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a07a18e8f862e8f96a79cc524ccd373f4">setState</a> (State s)</td></tr>
<tr class="memdesc:a07a18e8f862e8f96a79cc524ccd373f4 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter permettant de mettre à jour l'attribut state_.  <a href="class_character.html#a07a18e8f862e8f96a79cc524ccd373f4">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a07a18e8f862e8f96a79cc524ccd373f4 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0730f427cca827ac8e45c944517c30f4 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">const sf::Vector2i &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a0730f427cca827ac8e45c944517c30f4">getAnim</a> () const</td></tr>
<tr class="memdesc:a0730f427cca827ac8e45c944517c30f4 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de l'attribut privé anim_.  <a href="class_character.html#a0730f427cca827ac8e45c944517c30f4">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a0730f427cca827ac8e45c944517c30f4 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127e02a10121a42c821bb266fc51875f inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a127e02a10121a42c821bb266fc51875f">setPv</a> (int pv)</td></tr>
<tr class="memdesc:a127e02a10121a42c821bb266fc51875f inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter permettant de mettre à jour l'attribut pv.  <a href="class_character.html#a127e02a10121a42c821bb266fc51875f">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a127e02a10121a42c821bb266fc51875f inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd21d8988207243fc5d4c736a9ac216 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a3bd21d8988207243fc5d4c736a9ac216">getNum</a> () const</td></tr>
<tr class="memdesc:a3bd21d8988207243fc5d4c736a9ac216 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de l'attribut privé num_.  <a href="class_character.html#a3bd21d8988207243fc5d4c736a9ac216">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a3bd21d8988207243fc5d4c736a9ac216 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab606add6b5d7545c7a65844f3a345ca2 inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">const sf::RectangleShape &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#ab606add6b5d7545c7a65844f3a345ca2">getlifebar</a> () const</td></tr>
<tr class="memdesc:ab606add6b5d7545c7a65844f3a345ca2 inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de l'attribut lifebar_.  <a href="class_character.html#ab606add6b5d7545c7a65844f3a345ca2">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:ab606add6b5d7545c7a65844f3a345ca2 inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a2ad9f53d27359366352d8932c746f inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a79a2ad9f53d27359366352d8932c746f">setlifebar</a> (sf::RectangleShape rce)</td></tr>
<tr class="memdesc:a79a2ad9f53d27359366352d8932c746f inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter permettant de mettre à jour l'attribut lifebar_.  <a href="class_character.html#a79a2ad9f53d27359366352d8932c746f">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a79a2ad9f53d27359366352d8932c746f inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c08e30734ee6cd02a38afaef4ff582d inherit pub_methods_class_character"><td class="memItemLeft" align="right" valign="top"><a id="a0c08e30734ee6cd02a38afaef4ff582d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a0c08e30734ee6cd02a38afaef4ff582d">destructPointer</a> ()</td></tr>
<tr class="memdesc:a0c08e30734ee6cd02a38afaef4ff582d inherit pub_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant de détruire les pointeurs. <br /></td></tr>
<tr class="separator:a0c08e30734ee6cd02a38afaef4ff582d inherit pub_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Fonctions membres privÃ©es</h2></td></tr>
<tr class="memitem:a58acbc93da31e05609339593a5f7e8f1"><td class="memItemLeft" align="right" valign="top"><a id="a58acbc93da31e05609339593a5f7e8f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a58acbc93da31e05609339593a5f7e8f1">brain</a> ()</td></tr>
<tr class="memdesc:a58acbc93da31e05609339593a5f7e8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthodé privé permettant d'établir un chemin vers les joueurs grâce à l'algorithme a*. <br /></td></tr>
<tr class="separator:a58acbc93da31e05609339593a5f7e8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0f8c8cfe5fffff336836008d0c3306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#aaf0f8c8cfe5fffff336836008d0c3306">addAdjectentCell</a> (std::pair&lt; int, int &gt; &amp;n)</td></tr>
<tr class="memdesc:aaf0f8c8cfe5fffff336836008d0c3306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste à repérer les noeuds adjacents et à les ajouter ou non à la liste ouverte.  <a href="#aaf0f8c8cfe5fffff336836008d0c3306">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:aaf0f8c8cfe5fffff336836008d0c3306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb8fdca4b2728e2bfca80c41e18812d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a3bb8fdca4b2728e2bfca80c41e18812d">distance</a> (int x1, int y1, int x2, int y2)</td></tr>
<tr class="memdesc:a3bb8fdca4b2728e2bfca80c41e18812d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste donné la distance entre deux points.  <a href="#a3bb8fdca4b2728e2bfca80c41e18812d">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a3bb8fdca4b2728e2bfca80c41e18812d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf19e85838727dd7c83aad673c043df"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#adaf19e85838727dd7c83aad673c043df">bestNode</a> (std::map&lt; std::pair&lt; int, int &gt;, <a class="el" href="struct_node2.html">Node2</a> &gt; l)</td></tr>
<tr class="memdesc:adaf19e85838727dd7c83aad673c043df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste à repérer le meilleur noeud dans la liste ouverte.  <a href="#adaf19e85838727dd7c83aad673c043df">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:adaf19e85838727dd7c83aad673c043df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9460e2c56aa8e10dbd6589ab3c5a253a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a9460e2c56aa8e10dbd6589ab3c5a253a">addToClosedList</a> (std::pair&lt; int, int &gt; &amp;p)</td></tr>
<tr class="memdesc:a9460e2c56aa8e10dbd6589ab3c5a253a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste à ajouter un noeud dans la liste fermée  <a href="#a9460e2c56aa8e10dbd6589ab3c5a253a">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a9460e2c56aa8e10dbd6589ab3c5a253a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9f3c1693ea90a7e2d9673730d468a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a3a9f3c1693ea90a7e2d9673730d468a8">recoverPath</a> (<a class="el" href="struct_node2.html">Node2</a> <a class="el" href="class_enemy.html#a050a37a00d9c9a7391eea79b8c816273">start</a>, <a class="el" href="struct_node2.html">Node2</a> objectif)</td></tr>
<tr class="memdesc:a3a9f3c1693ea90a7e2d9673730d468a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste à établir un chemin grâce à la méthode brain.  <a href="#a3a9f3c1693ea90a7e2d9673730d468a8">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a3a9f3c1693ea90a7e2d9673730d468a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f5eda314360d3cd473f78f188133b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a07f5eda314360d3cd473f78f188133b7">nodeExistInList</a> (std::pair&lt; int, int &gt; n, std::map&lt; std::pair&lt; int, int &gt;, <a class="el" href="struct_node2.html">Node2</a> &gt; &amp;l)</td></tr>
<tr class="memdesc:a07f5eda314360d3cd473f78f188133b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste à vérifié si un noeud est présent ou non dans la liste fermée et dans la liste ouverte.  <a href="#a07f5eda314360d3cd473f78f188133b7">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a07f5eda314360d3cd473f78f188133b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8078fe16bf85822ef5fc1b1dfdbe23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#afe8078fe16bf85822ef5fc1b1dfdbe23">findDirection</a> (std::vector&lt; std::pair&lt; int, int &gt; &gt;v)</td></tr>
<tr class="memdesc:afe8078fe16bf85822ef5fc1b1dfdbe23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé permet à l'ennemi de savoir dans quel direction il doit aller.  <a href="#afe8078fe16bf85822ef5fc1b1dfdbe23">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:afe8078fe16bf85822ef5fc1b1dfdbe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daa8ab5dc5483970adc4f3989d0e848"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a8daa8ab5dc5483970adc4f3989d0e848">moveToPos</a> (std::vector&lt; std::pair&lt; int, int &gt; &gt;v)</td></tr>
<tr class="memdesc:a8daa8ab5dc5483970adc4f3989d0e848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste à faire déplacer l'ennemi grâce à sa liste de position à suivre et la méthode <a class="el" href="class_enemy.html#afe8078fe16bf85822ef5fc1b1dfdbe23" title="Méthode privé permet à l&#39;ennemi de savoir dans quel direction il doit aller. ">findDirection()</a>.  <a href="#a8daa8ab5dc5483970adc4f3989d0e848">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a8daa8ab5dc5483970adc4f3989d0e848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea245d057a0afcbbc4cdd91467b31e9"><td class="memItemLeft" align="right" valign="top"><a id="a8ea245d057a0afcbbc4cdd91467b31e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a8ea245d057a0afcbbc4cdd91467b31e9">isAdjacent</a> ()</td></tr>
<tr class="memdesc:a8ea245d057a0afcbbc4cdd91467b31e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé permettant à l'ennemi de savoir si un joueur est à coté de lui. \ return vrai si c'est le cas, faux sinon. <br /></td></tr>
<tr class="separator:a8ea245d057a0afcbbc4cdd91467b31e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e9f097d7d3ca15e63e529528fa7260"><td class="memItemLeft" align="right" valign="top"><a id="a85e9f097d7d3ca15e63e529528fa7260"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a85e9f097d7d3ca15e63e529528fa7260">loadTextureStart</a> ()</td></tr>
<tr class="memdesc:a85e9f097d7d3ca15e63e529528fa7260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste à chargé la texture de départ de l'ennemi. <br /></td></tr>
<tr class="separator:a85e9f097d7d3ca15e63e529528fa7260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0223f2d3a71d8d80f4e6e4d760f056b9"><td class="memItemLeft" align="right" valign="top"><a id="a0223f2d3a71d8d80f4e6e4d760f056b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a0223f2d3a71d8d80f4e6e4d760f056b9">loadTexture</a> ()</td></tr>
<tr class="memdesc:a0223f2d3a71d8d80f4e6e4d760f056b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste à chargé la texture de l'ennemi. <br /></td></tr>
<tr class="separator:a0223f2d3a71d8d80f4e6e4d760f056b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7507ac0410bd6c17076efd93875a4d3a"><td class="memItemLeft" align="right" valign="top"><a id="a7507ac0410bd6c17076efd93875a4d3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a7507ac0410bd6c17076efd93875a4d3a">uptadeSpritePosition</a> ()</td></tr>
<tr class="memdesc:a7507ac0410bd6c17076efd93875a4d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste à mettre à jour la position du sprite de l'ennemi. <br /></td></tr>
<tr class="separator:a7507ac0410bd6c17076efd93875a4d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0309eefb841e6b577b2b705d20eb2e70"><td class="memItemLeft" align="right" valign="top"><a id="a0309eefb841e6b577b2b705d20eb2e70"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a0309eefb841e6b577b2b705d20eb2e70">functionMovingEnemies</a> ()</td></tr>
<tr class="memdesc:a0309eefb841e6b577b2b705d20eb2e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode privé consiste à faire bouger automatiquement les ennemis vers les joueurs. <br /></td></tr>
<tr class="separator:a0309eefb841e6b577b2b705d20eb2e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Attributs privÃ©s</h2></td></tr>
<tr class="memitem:a050a37a00d9c9a7391eea79b8c816273"><td class="memItemLeft" align="right" valign="top"><a id="a050a37a00d9c9a7391eea79b8c816273"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a050a37a00d9c9a7391eea79b8c816273">start</a> = 0</td></tr>
<tr class="memdesc:a050a37a00d9c9a7391eea79b8c816273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé permettant à l'ennemi de calculer le chemin lors de son initialisation. <br /></td></tr>
<tr class="separator:a050a37a00d9c9a7391eea79b8c816273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7c69f5093dad62eee63ebb47f682ba"><td class="memItemLeft" align="right" valign="top"><a id="a9e7c69f5093dad62eee63ebb47f682ba"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a9e7c69f5093dad62eee63ebb47f682ba">idLevel</a> =1</td></tr>
<tr class="memdesc:a9e7c69f5093dad62eee63ebb47f682ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé permmettant de définir la difficulté qu'un ennemi doit avoir. <br /></td></tr>
<tr class="separator:a9e7c69f5093dad62eee63ebb47f682ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75421012a4fce0ba14f16732ec425f50"><td class="memItemLeft" align="right" valign="top"><a id="a75421012a4fce0ba14f16732ec425f50"></a>
<a class="el" href="class_game.html">Game</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a75421012a4fce0ba14f16732ec425f50">game</a> =nullptr</td></tr>
<tr class="memdesc:a75421012a4fce0ba14f16732ec425f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé représentant l'état du jeu courant. <br /></td></tr>
<tr class="separator:a75421012a4fce0ba14f16732ec425f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205b94cb0f9ed17e0d7ea11ddcd91709"><td class="memItemLeft" align="right" valign="top"><a id="a205b94cb0f9ed17e0d7ea11ddcd91709"></a>
std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a205b94cb0f9ed17e0d7ea11ddcd91709">pathToPlayer</a></td></tr>
<tr class="memdesc:a205b94cb0f9ed17e0d7ea11ddcd91709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé représentant la liste des positions à suivrent pour arriver aux joueurs. <br /></td></tr>
<tr class="separator:a205b94cb0f9ed17e0d7ea11ddcd91709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640c238be5791fa0ddb18098d1eed427"><td class="memItemLeft" align="right" valign="top"><a id="a640c238be5791fa0ddb18098d1eed427"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a640c238be5791fa0ddb18098d1eed427">indicePath</a></td></tr>
<tr class="memdesc:a640c238be5791fa0ddb18098d1eed427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé permettant de savoir à quel position l'ennemi est arrivé dans la liste de position à suivre vers les joueurs. <br /></td></tr>
<tr class="separator:a640c238be5791fa0ddb18098d1eed427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6a7e4f51f7fa7cf4f068d380382123"><td class="memItemLeft" align="right" valign="top"><a id="ada6a7e4f51f7fa7cf4f068d380382123"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#ada6a7e4f51f7fa7cf4f068d380382123">textChange</a> = false</td></tr>
<tr class="memdesc:ada6a7e4f51f7fa7cf4f068d380382123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé permettant de savoir si la texture de l'ennemi a changée. <br /></td></tr>
<tr class="separator:ada6a7e4f51f7fa7cf4f068d380382123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c157371e28e73bd6e2efda6ef2a8c28"><td class="memItemLeft" align="right" valign="top"><a id="a2c157371e28e73bd6e2efda6ef2a8c28"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a2c157371e28e73bd6e2efda6ef2a8c28">id</a></td></tr>
<tr class="memdesc:a2c157371e28e73bd6e2efda6ef2a8c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé représentant l'identifiant de l'ennemi. <br /></td></tr>
<tr class="separator:a2c157371e28e73bd6e2efda6ef2a8c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6056c9bac33ff483dd88b764e9ecc71c"><td class="memItemLeft" align="right" valign="top"><a id="a6056c9bac33ff483dd88b764e9ecc71c"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a6056c9bac33ff483dd88b764e9ecc71c">threadEnemies</a></td></tr>
<tr class="memdesc:a6056c9bac33ff483dd88b764e9ecc71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé permettant de lancer un thread pour le déplacement de l'ennemi. <br /></td></tr>
<tr class="separator:a6056c9bac33ff483dd88b764e9ecc71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28533e2e804d74ac9da53dd239035035"><td class="memItemLeft" align="right" valign="top"><a id="a28533e2e804d74ac9da53dd239035035"></a>
<a class="el" href="class_position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a28533e2e804d74ac9da53dd239035035">positionFirst</a></td></tr>
<tr class="memdesc:a28533e2e804d74ac9da53dd239035035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé représentant la position de départ de l'ennemi. <br /></td></tr>
<tr class="separator:a28533e2e804d74ac9da53dd239035035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa69f9286d06f5d7dfbece84fd870b05"><td class="memItemLeft" align="right" valign="top"><a id="aaa69f9286d06f5d7dfbece84fd870b05"></a>
std::map&lt; std::pair&lt; int, int &gt;, <a class="el" href="struct_node2.html">Node2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#aaa69f9286d06f5d7dfbece84fd870b05">openList</a></td></tr>
<tr class="memdesc:aaa69f9286d06f5d7dfbece84fd870b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé permettant de représenté la liste des noeuds à traité dans l'algorithme a* de l'ennemi. <br /></td></tr>
<tr class="separator:aaa69f9286d06f5d7dfbece84fd870b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c6813c3a13e8ce8502e60267261f02"><td class="memItemLeft" align="right" valign="top"><a id="a20c6813c3a13e8ce8502e60267261f02"></a>
std::map&lt; std::pair&lt; int, int &gt;, <a class="el" href="struct_node2.html">Node2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a20c6813c3a13e8ce8502e60267261f02">closedList</a></td></tr>
<tr class="memdesc:a20c6813c3a13e8ce8502e60267261f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé permettant de représenté la liste des noeuds qui ont déjà été traité par l'algorithme a* de l'ennemi. <br /></td></tr>
<tr class="separator:a20c6813c3a13e8ce8502e60267261f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f53dd791a309071c26c4ffd0400daf"><td class="memItemLeft" align="right" valign="top"><a id="af0f53dd791a309071c26c4ffd0400daf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#af0f53dd791a309071c26c4ffd0400daf">playerMove</a></td></tr>
<tr class="memdesc:af0f53dd791a309071c26c4ffd0400daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé permettant de savoir si un des jouers à effectué un mouvement. <br /></td></tr>
<tr class="separator:af0f53dd791a309071c26c4ffd0400daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c223e56ce9c0f0f362c85714d059d9"><td class="memItemLeft" align="right" valign="top"><a id="a16c223e56ce9c0f0f362c85714d059d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_enemy.html#a16c223e56ce9c0f0f362c85714d059d9">inversion</a> = false</td></tr>
<tr class="memdesc:a16c223e56ce9c0f0f362c85714d059d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribut privé permettant de savoir si il faudra lire inversémement le chemin donné par l'algorithme a* de l'ennemi. <br /></td></tr>
<tr class="separator:a16c223e56ce9c0f0f362c85714d059d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Membres hÃ©ritÃ©s additionnels</h2></td></tr>
<tr class="inherit_header pro_methods_class_character"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_character')"><img src="closed.png" alt="-"/>&#160;Fonctions membres protÃ©gÃ©es hÃ©ritÃ©s de <a class="el" href="class_character.html">Character</a></td></tr>
<tr class="memitem:adb72c58767b502243924aa58c078588c inherit pro_methods_class_character"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#adb72c58767b502243924aa58c078588c">setPositionHitbox</a> (float f1, float f2)</td></tr>
<tr class="memdesc:adb72c58767b502243924aa58c078588c inherit pro_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seteur de la position de la hitbox du personnage.  <a href="class_character.html#adb72c58767b502243924aa58c078588c">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:adb72c58767b502243924aa58c078588c inherit pro_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc749bf818c6eb0e9a149f0d5ccc760 inherit pro_methods_class_character"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a3fc749bf818c6eb0e9a149f0d5ccc760">setPosition</a> (unsigned x, unsigned y)</td></tr>
<tr class="memdesc:a3fc749bf818c6eb0e9a149f0d5ccc760 inherit pro_methods_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seteur de la position du personnage.  <a href="class_character.html#a3fc749bf818c6eb0e9a149f0d5ccc760">Plus de dÃ©tails...</a><br /></td></tr>
<tr class="separator:a3fc749bf818c6eb0e9a149f0d5ccc760 inherit pro_methods_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_character"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_character')"><img src="closed.png" alt="-"/>&#160;Attributs protÃ©gÃ©s hÃ©ritÃ©s de <a class="el" href="class_character.html">Character</a></td></tr>
<tr class="memitem:a0b12a6a9d9b6666642d18238533c2fa7 inherit pro_attribs_class_character"><td class="memItemLeft" align="right" valign="top"><a id="a0b12a6a9d9b6666642d18238533c2fa7"></a>
sf::Vector2i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#a0b12a6a9d9b6666642d18238533c2fa7">anim</a> { 1, Up }</td></tr>
<tr class="memdesc:a0b12a6a9d9b6666642d18238533c2fa7 inherit pro_attribs_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">represente l'orientation du personnage. <br /></td></tr>
<tr class="separator:a0b12a6a9d9b6666642d18238533c2fa7 inherit pro_attribs_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bb808a1bc3cb8dbcf398d4edbdb482 inherit pro_attribs_class_character"><td class="memItemLeft" align="right" valign="top"><a id="ac5bb808a1bc3cb8dbcf398d4edbdb482"></a>
sf::Texture *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#ac5bb808a1bc3cb8dbcf398d4edbdb482">perso_</a></td></tr>
<tr class="memdesc:ac5bb808a1bc3cb8dbcf398d4edbdb482 inherit pro_attribs_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">represente la texture d'un personnage. <br /></td></tr>
<tr class="separator:ac5bb808a1bc3cb8dbcf398d4edbdb482 inherit pro_attribs_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19aca204ea713cdd9cf84096b23fe6c inherit pro_attribs_class_character"><td class="memItemLeft" align="right" valign="top"><a id="ab19aca204ea713cdd9cf84096b23fe6c"></a>
sf::Sprite *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#ab19aca204ea713cdd9cf84096b23fe6c">spritePerso_</a></td></tr>
<tr class="memdesc:ab19aca204ea713cdd9cf84096b23fe6c inherit pro_attribs_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">represente le sprite d'un personnage. <br /></td></tr>
<tr class="separator:ab19aca204ea713cdd9cf84096b23fe6c inherit pro_attribs_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68eb1063fe0be7aa0e1f0b6a5b424b2 inherit pro_attribs_class_character"><td class="memItemLeft" align="right" valign="top"><a id="ae68eb1063fe0be7aa0e1f0b6a5b424b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_character.html#ae68eb1063fe0be7aa0e1f0b6a5b424b2">pv_</a></td></tr>
<tr class="memdesc:ae68eb1063fe0be7aa0e1f0b6a5b424b2 inherit pro_attribs_class_character"><td class="mdescLeft">&#160;</td><td class="mdescRight">represente les pv d'un personnage. <br /></td></tr>
<tr class="separator:ae68eb1063fe0be7aa0e1f0b6a5b424b2 inherit pro_attribs_class_character"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Documentation des constructeurs et destructeur</h2>
<a id="aae1f49e02a35dda5fac45028c3d3ea87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1f49e02a35dda5fac45028c3d3ea87">&sect;&nbsp;</a></span>Enemy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Enemy::Enemy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_position.html">Position</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_game.html">Game</a> *&#160;</td>
          <td class="paramname"><em>gam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur de la classe <a class="el" href="class_enemy.html">Enemy</a>. </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>La position de l'ennemi </td></tr>
    <tr><td class="paramname">pv</td><td>Les points de vie de l'ennemi </td></tr>
    <tr><td class="paramname">id</td><td>L'identifiant de l'ennemi </td></tr>
    <tr><td class="paramname">gam</td><td>L'état courant du jeux. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions membres</h2>
<a id="aaf0f8c8cfe5fffff336836008d0c3306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0f8c8cfe5fffff336836008d0c3306">&sect;&nbsp;</a></span>addAdjectentCell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Enemy::addAdjectentCell </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privé consiste à repérer les noeuds adjacents et à les ajouter ou non à la liste ouverte. </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>détermine la position du noeud courant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9460e2c56aa8e10dbd6589ab3c5a253a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9460e2c56aa8e10dbd6589ab3c5a253a">&sect;&nbsp;</a></span>addToClosedList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Enemy::addToClosedList </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privé consiste à ajouter un noeud dans la liste fermée </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>L identifiant du noeud qui sera rajouté dans la liste. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaf19e85838727dd7c83aad673c043df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf19e85838727dd7c83aad673c043df">&sect;&nbsp;</a></span>bestNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int, int &gt; Enemy::bestNode </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::pair&lt; int, int &gt;, <a class="el" href="struct_node2.html">Node2</a> &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privé consiste à repérer le meilleur noeud dans la liste ouverte. </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>détermine la position du noeud courant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bb8fdca4b2728e2bfca80c41e18812d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb8fdca4b2728e2bfca80c41e18812d">&sect;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Enemy::distance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privé consiste donné la distance entre deux points. </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>la position en absisse du premier point. </td></tr>
    <tr><td class="paramname">y1</td><td>la position en ordonné du premier point. </td></tr>
    <tr><td class="paramname">x2</td><td>la position en absisse du deuxième point. </td></tr>
    <tr><td class="paramname">y2</td><td>la position en ordonné du deuxième point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>la distance entre les deux points. </dd></dl>

</div>
</div>
<a id="afe8078fe16bf85822ef5fc1b1dfdbe23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8078fe16bf85822ef5fc1b1dfdbe23">&sect;&nbsp;</a></span>findDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Enemy::findDirection </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privé permet à l'ennemi de savoir dans quel direction il doit aller. </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>la liste des positions que l'ennemi doit suivre. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>un entier qui représente la direction que l'ennemi doit suivre. </dd></dl>

</div>
</div>
<a id="a03176597f71929d302c8fb0d414c203b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03176597f71929d302c8fb0d414c203b">&sect;&nbsp;</a></span>getPositionFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_position.html">Position</a> &amp; Enemy::getPositionFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode public consiste à donné la position de départ de l'ennemi. </p>
<dl class="section return"><dt>Renvoie</dt><dd>la position de départ de l'ennemi. </dd></dl>

</div>
</div>
<a id="a8daa8ab5dc5483970adc4f3989d0e848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daa8ab5dc5483970adc4f3989d0e848">&sect;&nbsp;</a></span>moveToPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Enemy::moveToPos </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privé consiste à faire déplacer l'ennemi grâce à sa liste de position à suivre et la méthode <a class="el" href="class_enemy.html#afe8078fe16bf85822ef5fc1b1dfdbe23" title="Méthode privé permet à l&#39;ennemi de savoir dans quel direction il doit aller. ">findDirection()</a>. </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>La liste de position à suivre. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07f5eda314360d3cd473f78f188133b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f5eda314360d3cd473f78f188133b7">&sect;&nbsp;</a></span>nodeExistInList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Enemy::nodeExistInList </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::pair&lt; int, int &gt;, <a class="el" href="struct_node2.html">Node2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privé consiste à vérifié si un noeud est présent ou non dans la liste fermée et dans la liste ouverte. </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>L'identifiant du noeud à vérifié </td></tr>
    <tr><td class="paramname">l</td><td>La liste que l'on va testé. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a9f3c1693ea90a7e2d9673730d468a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9f3c1693ea90a7e2d9673730d468a8">&sect;&nbsp;</a></span>recoverPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; int, int &gt; &gt; Enemy::recoverPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node2.html">Node2</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_node2.html">Node2</a>&#160;</td>
          <td class="paramname"><em>objectif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode privé consiste à établir un chemin grâce à la méthode brain. </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Le noeud de départ. </td></tr>
    <tr><td class="paramname">objectif</td><td>Le noeud objectif que l'on veut atteindre </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>le chemin qui va du départ jusqu'à l'objectif. </dd></dl>

</div>
</div>
<a id="a7ab66e83364e9672785e6da47b503a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab66e83364e9672785e6da47b503a76">&sect;&nbsp;</a></span>setPlayerMoving()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Enemy::setPlayerMoving </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode public consiste à mettre à jour l'attribut qui détermine si un joueur a bouger. </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>La nouvelle valeur à donner à l'attribut </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>La documentation de cette classe a Ã©tÃ© gÃ©nÃ©rÃ©e Ã  partir des fichiers suivants :<ul>
<li><a class="el" href="_enemy_8h_source.html">Enemy.h</a></li>
<li>Enemy.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
GÃ©nÃ©rÃ© par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
